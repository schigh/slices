package main

import (
	"fmt"
	"os"
	"path"

	"bytes"
	"github.com/schigh/slices"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"io/ioutil"
	"strings"
	"time"
)

const newlineStr = `
`

const headtmplStr = `// generated by slices (github.com/schigh/slices).  do not edit.
// gen date: {{.GenDate}}

package {{.PackageName}}

// {{.SourceStruct}}Slice aliases []{{.SourceStruct}}
type {{.SourceStruct}}Slice []{{.SourceStruct}}

// Value returns the wrapped {{.SourceStruct}} slice
func (slice {{.SourceStruct}}Slice) Value() []{{.SourceStruct}} {
	return []{{.SourceStruct}}(slice)
}
`

const maptmplStr = `// Map applies a function to every {{.SourceStruct}} in the slice.  This function will mutate the slice in place
func (slice {{.SourceStruct}}Slice) Map(f func(*{{.SourceStruct}})) {
	for i, instance := range slice {
		f(&instance)
		slice[i] = instance
	}
}
`

const eachtmplStr = `// Each applies a function to every {{.SourceStruct}} in the slice.  This function will NOT mutate the slice in place
func (slice {{.SourceStruct}}Slice) Each(f func(*{{.SourceStruct}})) {
	for _, instance := range slice {
		f(&instance)
	}
}
`

const filtertmplStr = `// Filter evaluates every element in the slice, and returns all {{.SourceStruct}} 
// instances where the eval function returns true
func (slice {{.SourceStruct}}Slice) Filter(f func(*{{.SourceStruct}}) bool) {{.SourceStruct}}Slice {
	out := make([]{{.SourceStruct}}, 0, len(slice))
	for _, instance := range slice {
		if f(&instance) {
			out = append(out, instance)
		}
	}

	return {{.SourceStruct}}Slice(out)
}
`

const (
	filterStr = "filter"
	mapStr    = "map"
	eachStr   = "each"
)

type tmpl struct {
	PackageName  string
	GenDate      string
	SourceStruct string
	Inclusions   []string
}

var (
	targetPackage string
	targetStruct  string
	targetFile    string
)

func printErr(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "\033[31mslices: "+msg+"\n", args...)
}

func printSuccess(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stdout, "\033[32mslices: "+msg+"\n", args...)
}

func main() {
	// make sure args are ok
	if len(os.Args) < 2 {
		printErr("usage: slices <struct> ...<funcs>")
		os.Exit(1)
	}

	// make sure env vars exist
	targetPackage = os.Getenv("GOPACKAGE")
	targetFile = os.Getenv("GOFILE")

	if targetPackage == "" || targetFile == "" {
		printErr("both GOPACKAGE and GOFILE environment variables are required")
	}
	targetStruct = os.Args[1]

	// assemble file path
	pwd, pwdErr := os.Getwd()
	if pwdErr != nil {
		printErr("unable to get pwd: %v", pwdErr)
		os.Exit(1)
	}
	targetFile = path.Join(pwd, targetFile)

	// make sure a struct by the provided name lives in this file
	found, parseErr := parseFileAndLocateStruct(targetFile, targetStruct)
	if parseErr != nil {
		printErr("error parsing file %s: %v", targetFile, parseErr)
		os.Exit(1)
	}

	if !found {
		printErr("unable to locate struct %s in file %s", targetStruct, targetFile)
		os.Exit(1)
	}

	// determine scope
	scope := slices.StringSlice(os.Args[2:]).Unique().Value()
	allowed := slices.StringSlice([]string{filterStr, mapStr, eachStr})
	var includes, excludes []string
	for _, s := range scope {
		if len(s) > 0 && s[0] == '-' {
			ss := string(s[1:])
			if !allowed.Contains(ss) {
				printErr("illegal operation '%s' in file %s", ss, targetFile)
				os.Exit(1)
			}
			excludes = append(excludes, ss)
		} else {
			if !allowed.Contains(s) {
				printErr("illegal operation '%s' in file %s", s, targetFile)
				os.Exit(1)
			}
			includes = append(includes, s)
		}
	}

	all := len(includes) == 0
	if !all {
		// if we're not generating all funcs, then ignore any excludes
		excludes = nil
	} else {
		// otherwise, set includes to all allowed funcs
		includes = allowed.Value()
	}

	// filter out all excludes from includes, then sort
	includes = slices.StringSlice(includes).Filter(func(s string) bool {
		return !slices.StringSlice(excludes).Contains(s)
	}).SortAsc().Value()

	t := &tmpl{
		PackageName:  targetPackage,
		GenDate:      time.Now().Format(time.RFC1123Z),
		SourceStruct: targetStruct,
		Inclusions:   includes,
	}

	fileBytes, outErr := generateOutBytes(t)
	if outErr != nil {
		os.Exit(1)
	}

	outfile := path.Join(path.Dir(targetFile), fmt.Sprintf("%s_slices.go", strings.ToLower(targetStruct)))
	if writeFileErr := ioutil.WriteFile(outfile, fileBytes, 0644); writeFileErr != nil {
		printErr("error writing to file %s: %v", targetFile, writeFileErr)
		os.Exit(1)
	}

	printSuccess("wrote file %s", outfile)
}

func parseFileAndLocateStruct(filePath, targetStruct string) (bool, error) {
	fset := token.NewFileSet()
	node, parseErr := parser.ParseFile(fset, filePath, nil, parser.AllErrors)
	if parseErr != nil {
		return false, parseErr
	}

	var found bool
	var structName string
	ast.Inspect(node, func(n ast.Node) bool {
		switch t := n.(type) {
		case *ast.TypeSpec:
			structName = t.Name.String()
		case *ast.StructType:
			if structName == targetStruct {
				found = true
				return false
			}
		}
		return true
	})

	return found, nil
}

func generateOutBytes(tmpl *tmpl) ([]byte, error) {
	var b []byte
	bBuff := bytes.NewBuffer(b)

	var tmplErr error
	headTmpl, tmplErr := template.New("head").Parse(headtmplStr)
	if tmplErr != nil {
		printErr("parsing template failed for headtmplStr: %v", tmplErr)
		return nil, tmplErr
	}
	if headTmplErr := headTmpl.Execute(bBuff, tmpl); headTmplErr != nil {
		printErr("executing template failed for headtmplStr: %v", headTmplErr)
		return nil, headTmplErr
	}
	bBuff.Write([]byte(newlineStr))

	if slices.StringSlice(tmpl.Inclusions).Contains(mapStr) {
		mapTmpl, tmplErr := template.New("map").Parse(maptmplStr)
		if tmplErr != nil {
			printErr("parsing template failed for maptmplStr: %v", tmplErr)
			return nil, tmplErr
		}
		if mapTmplErr := mapTmpl.Execute(bBuff, tmpl); mapTmplErr != nil {
			printErr("executing template failed for maptmplStr: %v", mapTmplErr)
			return nil, mapTmplErr
		}
		bBuff.Write([]byte(newlineStr))
	}

	if slices.StringSlice(tmpl.Inclusions).Contains(eachStr) {
		eachTmpl, tmplErr := template.New("each").Parse(eachtmplStr)
		if tmplErr != nil {
			printErr("parsing template failed for eachtmplStr: %v", tmplErr)
			return nil, tmplErr
		}
		if eachTmplErr := eachTmpl.Execute(bBuff, tmpl); eachTmplErr != nil {
			printErr("executing template failed for eachtmplStr: %v", eachTmplErr)
			return nil, eachTmplErr
		}
		bBuff.Write([]byte(newlineStr))
	}

	if slices.StringSlice(tmpl.Inclusions).Contains(filterStr) {
		filterTmpl, tmplErr := template.New("package").Parse(filtertmplStr)
		if tmplErr != nil {
			printErr("parsing template failed for filtertmplStr: %v", tmplErr)
			return nil, tmplErr
		}
		if filterTmplErr := filterTmpl.Execute(bBuff, tmpl); filterTmplErr != nil {
			printErr("executing template failed for filtertmplStr: %v", filterTmplErr)
			return nil, filterTmplErr
		}
		bBuff.Write([]byte(newlineStr))
	}

	return bBuff.Bytes(), nil
}
