package internal

// Template encapsulates template params
type Template struct {
	PO           bool // pointer override
	PackageName  string
	GenDate      string
	SourceStruct string
	Operations   []Operation
}

// SliceTemplate aliases string
type SliceTemplate string

// String just returns the template's proper string value
func (t SliceTemplate) String() string {
	return string(t)
}

// HeadTmpl is the header template for all generated slice files
const HeadTmpl = SliceTemplate(`package {{.PackageName}}

/* generated by slices (github.com/schigh/slices).  do not edit. */
/* gen date: {{.GenDate}} */

// {{.SliceTypeName}}Slice aliases []{{if .PO}}*{{end}}{{.SourceStruct}}
type {{.SliceTypeName}}Slice []{{if .PO}}*{{end}}{{.SourceStruct}}

// Value returns the wrapped {{.SourceStruct}} slice
func (slice {{.SliceTypeName}}Slice) Value() []{{if .PO}}*{{end}}{{.SourceStruct}} {
	return []{{if .PO}}*{{end}}{{.SourceStruct}}(slice)
}

`)

// MapTmpl is the map function
const MapTmpl = SliceTemplate(`// Map applies a function to every {{.SourceStruct}} in the slice.  This function will mutate the slice in place{{if .PO}}
func (slice {{.SliceTypeName}}Slice) Map(f func(*{{.SourceStruct}}) *{{.SourceStruct}}) {
	for i := 0; i < len(slice); i++ {
		slice[i] = f(slice[i])
	}
}

{{else}}
func (slice {{.SliceTypeName}}Slice) Map(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) {{if .ByRef}}*{{end}}{{.SourceStruct}}) {
	for i := 0; i < len(slice); i++ {
		{{if .ByRef}}v := f(&slice[i])
		slice[i] = *v{{else}}slice[i] = f(slice[i]){{end}}
	}
}

{{end}}`)

// EachTmpl is the each function
const EachTmpl = SliceTemplate(`// Each applies a function to every {{.SourceStruct}} in the slice.{{if .PO}}
func (slice {{.SliceTypeName}}Slice) Each(f func(*{{.SourceStruct}})) {
	for i := 0; i < len(slice); i++ {
		f(slice[i])
	}
}

{{else}}
func (slice {{.SliceTypeName}}Slice) Each(f func({{if .ByRef}}*{{end}}{{.SourceStruct}})) {
	for i := 0; i < len(slice); i++ {
		f({{if .ByRef}}&{{end}}slice[i])
	}
}

{{end}}`)

// TryEachTmpl is the TryEach function
const TryEachTmpl = SliceTemplate(`// TryEach applies a function to every {{.SourceStruct}} in the slice,
// and returns the index of the element that caused the first error, and the error itself.  
// If every member of the slice returns nil, this function will return (-1, nil)
// The iteration will halt on the first error encountered and return it.{{if .PO}}
func (slice {{.SliceTypeName}}Slice) TryEach(f func(*{{.SourceStruct}}) error) (int, error) {
	for i := 0; i < len(slice); i++ {
		if err := f(slice[i]); err != nil {
			return i, err
		}
	}

	return -1, nil
}

{{else}}
func (slice {{.SliceTypeName}}Slice) TryEach(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) error) (int, error) {
	for i := 0; i < len(slice); i++ {
		if err := f({{if .ByRef}}&{{end}}slice[i]); err != nil {
			return i, err
		}
	}

	return -1, nil
}

{{end}}`)

// IfEachTmpl is the IfEach function
const IfEachTmpl = SliceTemplate(`// IfEach applies a function to every {{.SourceStruct}} in the slice,
// and returns the index of the element that caused the function to return false.  
// If every member of the slice evaluates to true, this function will return (-1, true)
// The iteration will halt on the first false return from the function.{{if .PO}}
func (slice {{.SliceTypeName}}Slice) IfEach(f func(*{{.SourceStruct}}) bool) (int, bool) {
	for i := 0; i < len(slice); i++ {
		if !f(slice[i]) {
			return i, false
		}
	}

	return -1, true
}

{{else}}
func (slice {{.SliceTypeName}}Slice) IfEach(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) bool) (int, bool) {
	for i := 0; i < len(slice); i++ {
		if !f({{if .ByRef}}&{{end}}slice[i]) {
			return i, false
		}
	}

	return -1, false
}

{{end}}`)

// FilterTmpl is the filter function
const FilterTmpl = SliceTemplate(`// Filter evaluates every element in the slice, and returns all {{.SourceStruct}} 
// instances where the eval function returns true{{if .PO}}
func (slice {{.SliceTypeName}}Slice) Filter(f func(*{{.SourceStruct}}) bool) {{.SliceTypeName}}Slice {
	out := make([]*{{.SourceStruct}}, 0, len(slice))
	for i := 0; i < len(slice); i++ {
		if f(slice[i]) {
			out = append(out, slice[i])
		}
	}

	return {{.SliceTypeName}}Slice(out)
}

{{else}}
func (slice {{.SliceTypeName}}Slice) Filter(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) bool) {{.SliceTypeName}}Slice {
	out := make([]{{.SourceStruct}}, 0, len(slice))
	for i := 0; i < len(slice); i++ {
		if f({{if .ByRef}}&{{end}}slice[i]) {
			out = append(out, slice[i])
		}
	}

	return {{.SliceTypeName}}Slice(out)
}

{{end}}`)
