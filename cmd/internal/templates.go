package internal

// Template encapsulates template params
type Template struct {
	PO           bool // pointer override
	PackageName  string
	GenDate      string
	SourceStruct string
	Operations   []Operation
}

// SliceTemplate aliases string
type SliceTemplate string

// String just returns the template's proper string value
func (t SliceTemplate) String() string {
	return string(t)
}

// HeadTmpl is the header template for all generated slice files
const HeadTmpl = SliceTemplate(`// generated by slices (github.com/schigh/slices).  do not edit.
// gen date: {{.GenDate}}

package {{.PackageName}}

// {{.SliceTypeName}}Slice aliases []{{if .PO}}*{{end}}{{.SourceStruct}}
type {{.SliceTypeName}}Slice []{{if .PO}}*{{end}}{{.SourceStruct}}

// Value returns the wrapped {{.SourceStruct}} slice
func (slice {{.SliceTypeName}}Slice) Value() []{{if .PO}}*{{end}}{{.SourceStruct}} {
	return []{{if .PO}}*{{end}}{{.SourceStruct}}(slice)
}

`)

// MapTmpl is the map function
const MapTmpl = SliceTemplate(`// Map applies a function to every {{.SourceStruct}} in the slice.  This function will mutate the slice in place{{if .PO}}
func (slice {{.SliceTypeName}}Slice) Map(f func(*{{.SourceStruct}}) *{{.SourceStruct}}) {
	for i, v := range slice {
		slice[i] = f(v)
	}
}

{{else}}
func (slice {{.SliceTypeName}}Slice) Map(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) {{if .ByRef}}*{{end}}{{.SourceStruct}}) {
	for i, v := range slice {
		{{if .ByRef}}v := f(&v)
		slice[i] = *v{{else}}slice[i] = f(v){{end}}
	}
}

{{end}}`)

// EachTmpl is the each function
const EachTmpl = SliceTemplate(`// Each applies a function to every {{.SourceStruct}} in the slice.{{if .PO}}
func (slice {{.SliceTypeName}}Slice) Each(f func(*{{.SourceStruct}})) {
	for _, v := range slice {
		f(v)
	}
}

{{else}}
func (slice {{.SliceTypeName}}Slice) Each(f func({{if .ByRef}}*{{end}}{{.SourceStruct}})) {
	for _, v := range slice {
		f({{if .ByRef}}&{{end}}v)
	}
}

{{end}}`)

const CheckEachTmpl = SliceTemplate(`// CheckEach applies a function to every {{.SourceStruct}} in the slice,
// and returns an error.  The iteration will halt on the first error
// encountered and return it.{{if .PO}}
func (slice {{.SliceTypeName}}Slice) CheckEach(f func(*{{.SourceStruct}}) error) error {
	for _, v := range slice {
		if err := f(v); err != nil {
			return err
		}
	}

	return nil
}

{{else}}
func (slice {{.SliceTypeName}}Slice) CheckEach(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) error) error {
	for _, v := range slice {
		if err := f({{if .ByRef}}&{{end}}v); err != nil {
			return err
		}
	}

	return nil
}

{{end}}`)

// FilterTmpl is the filter function
const FilterTmpl = SliceTemplate(`// Filter evaluates every element in the slice, and returns all {{.SourceStruct}} 
// instances where the eval function returns true{{if .PO}}
func (slice {{.SliceTypeName}}Slice) Filter(f func(*{{.SourceStruct}}) bool) {{.SliceTypeName}}Slice {
	out := make([]*{{.SourceStruct}}, 0, len(slice))
	for _, v := range slice {
		if f(v) {
			out = append(out, v)
		}
	}

	return {{.SliceTypeName}}Slice(out)
}

{{else}}
func (slice {{.SliceTypeName}}Slice) Filter(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) bool) {{.SliceTypeName}}Slice {
	out := make([]{{.SourceStruct}}, 0, len(slice))
	for _, v := range slice {
		if f({{if .ByRef}}&{{end}}v) {
			out = append(out, v)
		}
	}

	return {{.SliceTypeName}}Slice(out)
}

{{end}}`)
