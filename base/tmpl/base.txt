{{/*
	.BaseType
	-	the base go type (int, uint, etc)
	
	.PackageType
	-	the slice alias name (Int, Int16, etc)
	
*/}}
package slices

import "sort"

/* generated by github.com/schigh/slices/base/base.go.  do not edit. */

// {{.PackageType}} is the alias of []{{.BaseType}}
type {{.PackageType}} []{{.BaseType}}

// Value returns the aliased []{{.BaseType}}
func (slice {{.PackageType}}) Value() []{{.BaseType}} {
	return []{{.BaseType}}(slice)
}

// IndexOf returns the first index of needle, or -1 if not found
func (slice {{.PackageType}}) IndexOf(needle {{.BaseType}}) int {
	for idx, n := range slice {
		if needle == n {
			return idx
		}
	}

	return NotInSlice
}

// Contains returns true if the slice contains needle
func (slice {{.PackageType}}) Contains(needle {{.BaseType}}) bool {
	return slice.IndexOf(needle) != NotInSlice
}

// SortAsc will sort the slice in ascending order
func (slice {{.PackageType}}) SortAsc() {{.PackageType}} {
	sort.SliceStable(slice, func(i, j int) bool {
		return slice[i] < slice[j]
	})
	return slice
}

// SortDesc will sort the slice in descending order
func (slice {{.PackageType}}) SortDesc() {{.PackageType}} {
	sort.SliceStable(slice, func(i, j int) bool {
		return slice[j] < slice[i]
	})
	return slice
}

// Reverse will reverse the order of the slice
func (slice {{.PackageType}}) Reverse() {{.PackageType}} {
	l := len(slice)
	for i, j := 0, l-1; i < l/2; i++ {
		slice[i], slice[j] = slice[j], slice[i]
		j--
	}

	return slice
}

// Unique filters out duplicate {{.BaseType}} values
func (slice {{.PackageType}}) Unique() {{.PackageType}} {
	u := make([]{{.BaseType}}, 0, len(slice))
	m := make(map[{{.BaseType}}]bool)

	for _, v := range slice {
		if _, ok := m[v]; !ok {
			m[v] = true
			u = append(u, v)
		}
	}

	return {{.PackageType}}(u)
}

// Filter will return all {{.BaseType}} values that evaluate true in the user-supplied function
func (slice {{.PackageType}}) Filter(f func({{.BaseType}}) bool) {{.PackageType}} {
	out := make([]{{.BaseType}}, 0, len(slice))
	for _, v := range slice {
		if f(v) {
			out = append(out, v)
		}
	}

	return {{.PackageType}}(out)
}

// Each will apply a function to each {{.BaseType}} in the slice.
// This should be used with data outside of the slice as it doesn't mutate it
func (slice {{.PackageType}}) Each(f func({{.BaseType}})) {
	for _, v := range slice {
		f(v)
	}
}

// Map will apply a function to each {{.BaseType}} in the slice and replace the previous value
func (slice {{.PackageType}}) Map(f func({{.BaseType}}) {{.BaseType}}) {
	for i, v := range slice {
		slice[i] = f(v)
	}
}
